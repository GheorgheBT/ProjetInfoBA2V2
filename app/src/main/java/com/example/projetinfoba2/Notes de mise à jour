Mise à jour du 01/04/2023 :
 -  J'ai forcé l'application a etre en mode paysage. Je suppose que dans sa version finale elle sera en mode paysage du coup je l'ai forcé pour
    voir un peu la position des différents objets (car ils changent de place quand on alterne portrait/paysage)
 -  J'ai créé l'objet joystick mais j'ai pas encore implémenté ses fonctions (faire bouger le perso, mettre a jour le joystick, etc),
    je rajouterai aussi plus de commentaires


Mise à jour du 06/04/2023 :
 - j'ai ajouté une nouvelle activité de demarage qui nous permetra de parametrer l'affichage avant de commencer le jeux
  C'est WelcomeActivity avec son fichier xml "activity_welcome"
 - j'ai aussi mis les interactions balles joueur et obstacles mais c'est pas encore tres formel

Mise à jour du 07/04/2023 :
    - j'ai transformé le joystick en une vue et on le controle dans le main
    j'ai enlevé le touch listener du drawingview et je l'utilise que pour le
    joystick(dans main) et bouton tir (qui n'est plus un objet qu'on a créé mais un bouton normal qu'on a override),
    d'apres ce que j'ai compris en chercheant sur internet, c'est mieux si on différencie les différents composants(vues, objets, etc)
    et vu que notre Drawingview n'a pas besin de listener car on utilise des boutons et joysticks, j'ai mis le listener sur ceux-ci
    (et d'ailleurs par cette methode ca evite des erreurs que j'avais ou j'avais besoin d'appeler le meme objet dans d'autres classes)
    si on rajoute des boutons supplémentaires, on rajoute le code dans main, la ou se trouve l'annotation
    -J'ai aussi changé l'affichage du joystick et bouton comme ca ils sont un peu plus joli
    - Petite note supp: je pense que c'est mieux qu'on fasse le plus possible de fonctions séparées qui interractent dans le code principal,
    car pour l'instant les codes principaux son souvents en un block sonc quand le github a été mis à jour, ca a provoqué bcp d'erreurs dans mon code
    du coup en faisant des fonctions indépendantes on a juste a modifier la fonction (et peut etre legerement le code principal) et ca va créer moins d'erreurs

   - oui pour les fonctions avec trop de lignes de code j'ai change ca pcq c'est pas pretique et c'est dure de sy retrouver j'ai aussi normalement resolu le probleme des des versions

Mise à jour du 08/04/2023 :
    - concernant le signe dans le rectf de l'obstacle, android studio considere les x positifs vers la droite et les y positifs vers le bas (0,0) coin supérieur gauche.
    Donc en mettant un moins, la valeur "bottom" se trouve au dessus de la valeur "top", du coup ca dessine pas.
    - La detection de collision entre joueur et obstacle se fait dans la classe joueur (d'un point de vue pratique je pense que c'est mieux, et aussi plus facile a comprendre)
    - Vu que le code m'a pris pas mal de temps, je n'ai pas fait la detection de collision entre balle et obstacle cassable mais ma démarche est :
        1. On fait une classe fille "Objet cassable", qui hérite de objet (ou si on veut pas faire de classe on ajoute le parametre "isDestructible" à la classe objet, donc a voir ce qu'on préfère)
        2. On ajoute une détection de collision aux balles, de la meme facon que le joueur(le coté de la collision n'est plus nécessaire ici), et si la collision a lieu, et l'objet est destructible (vérification de type ou de Boolean si on ne fait pas d'héritage), on appelle la fonction destroy de l'obstacle destructible(ce qui l'enleve de la liste)
        3. On appelle ensuite la fonction destroy de la balle (qui l'enleve de la liste)
    - Le projectile ennemi devrait par contre etre une autre type de classe (peut etre souclasse de projectile, dans lauquelle on override la fonction detecter collision pour ne detecter que le joueur et en cas de collision, le joueur perd une vie)
    - Dans le drawingview de la ligne 57 a 72 il y a la gestion des balles et obstacle, j'ai peur de casser des trucs en modifiant les "if" mais ce qu'il faut c'est juste de enlever la detection de collision du mur, et mettre juste l'affichage comme c'est fait pour les ennemis plus bas.
    - Dans la classe obstacle, il faut enlever la fonction istouched, car le code de collision a été déplacé dans joueur et dans la fonction isOnScreen il faut aussi enlever la 2e condition
    mais les 2 dernier points c'est mieux que tu les fasse car je ne veux pas faire d'erreurs
    Qu'est ce que tu en penses?

Mise à jour du 13/04/2023 :
    - j'ai modifié la classe projectile selon les propositions ci-dessus ( j'ai ajouté une methode getCollison dans la classe projcetile et une methode  Destroy dans le drawingView (qui se charge d'actualiser les listes) ) les obstacles on maintenant un attribut destructible
    - j'ai rajouté un sembant d'effet de rebond au du joueur au contacte des obstacle comme ca

Mise à jour du 14/04/2023 :
    - Ajout de 2 coroutines simples lors de la detection de tous les objets pour les collisions (dans la classe joueur et projectile)
    - Modification du fonctionnement du bouton tir : on peut tenir appuyer et le bouton tire a un certain intervalle
    de plus, si on spamme les balles ne spawnent pas trop fréquemment
    - ajout du nombre de fps pour avoir une idée des performances
    - dans le drawingview j'ai l'impression que la division en fonction update et run n'est pas nécessaire, on pourrait peut ettre les fusionner ?
    - Je penseais a transformer la detection de collision en une initerface, et la classe joueur et projectile l'utiliserai ? tu en penses quoi? (je peux m'en occuper si on le fait)
    - Je penseais a donner plus de structure/ logique aux obstacles qui aparaissent( tout en gardant l'aspect aléatoire). (je peux aussi le faire)
    - j'ai modifié les vitesses des balles(15->20) et joueur(20-15) comme ca le joueur ne dépasse pas les balles et ne bouge pas trop vite

Mise a jour du 20/04/2022:
    - j'ai ajouté la methode de la boite de dialogue de fin de jeu dans la MainActivity apres je sais pas si c'est la qu'on doit la mettre mais vu que c'est aussi un vue je me suis proposé de la metre la
    et puis c'est plus facile a programmer comme ca
    -il faudra aussi correctement implementer la maniere dont elle va se declancher pcq pour l'instant c'est du bricolage